---
{"dg-publish":true,"permalink":"/1-cs/4/","created":"2025-03-05T12:49:33.441+09:00","updated":"2025-03-13T16:41:32.414+09:00"}
---

## TCP/IP의 각 계층

- TCP/IP: 인터넷에서 표준으로 사용되고 있는 네트워크 프로토콜(규칙)을 의미한다.

- TCP/IP 5계층 (4계층은 물리와 링크를 합친 형태이다.)
	- 애플리케이션 계층 (L5)
		네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳이다.
		HTTP, SMTP, FTP와 같은 많은 프로토콜을 포함한다.
		DNS(Domain Name Server)를 지원한다. 
		애플리케이션 계층의 패킷을 **메시지**라고 한다.
	
	- 트랜스포트 계층 (L4)
		네트워크 계층에서 보내온 데이터를 정렬, 오류 정정 등을 수행하고 **신뢰할 수 있는 통신을 확보**한다.
		TCP/UDP 같은 프로토콜이 이 계층에 위치한다. 
		트랜스포트 계층의 패킷을 **세그먼트**라고 한다.
	
	- 네트워크 계층 (L3)
		다른 네트워크에 있는 몯적지에 데이터를 전송하는 역할을 수행한다. 즉 **네트워크 간의 통신을 가능하게 해주는 역할이다.**
		이를 위해 라우터 장비와 IP 프로토콜(하나만 존재), 라우팅 프로토콜이 사용된다.
		라우팅 프로토콜: 다른 네트워크와 통신하기 위해 경로를 설정하고 논리주소를 결정하는 역할을 수행한다.
		네트워크 계층에서의 패킷을 **데이터그램**이라 한다.
	
	- 링크 계층(데이터 링크라고도 함) (L2)
		**네트워크 기기 간 데이터 전송 밑 물리 주소를 결정하는 역할을 수행한다**. 주로 건물이나 특정 지역을 범위로 하는 네트워 크인 **랜(LAN)에서 데이터를 정상적으로 주고받기 위해 필요한 계층이다.**
		일반적으로 이더넷 프로토콜과 스위치와 같은 장비가 사용된다.
		링크 계층의 패킷을 **프레임**이라고 한다.
	
	- 물리 계층(L1)
		물리적인 연결과 전기 신호 변화/제어를 담당하여, 이진 데이터를 전기 신호로 변환한다. 또한 **컴퓨터와 네트워크 장비를 물리적으로 연결**하여, **하나의 노드에서 다른 노드로 비트를 이동시키는 역할을 수행한다.**
		물리 계층의 프로토콜들은 링크(실제 전송매체(광케이블))에 의존한다.
	![Pasted image 20250305132624.png](/img/user/images/Pasted%20image%2020250305132624.png)

---
## OSI 7계층과 TCP/IP의 계층의 차이

![Pasted image 20250305132743.png](/img/user/images/Pasted%20image%2020250305132743.png)
- OSI 7계층: TCP/IP 계층의 애플리케이션 계층을 더 세분화한 것이다.
	(앞서 설명한 계층은 제외)
	- 응용 계층
		**사용자 or 애플리케이션이 네트워크에 접근할 수 있도록 도와주는 계층이다. 사용자에게 보여지는 유일한 계층**이며 메일 전송, 인터넷 접속 등의 작업을 수행할 수 있다.
		
	- 표현 계층
		**응용 계층으로부터 전달받거나 전송하는 데이터의 인코딩 및 디코딩이 이루어지는 계층이다.** 응용 계층에서 데이터를 이해할 수 있도록 **응용 프로그램에 맞춰 변환하게 된다.** 예를들어, JPEG, TIFF, GIF, MPEG 등의 다양한 포맷을 구분하게 된다.
		
	- 세션 계층
		**응용 프로세스가 통신을 관리하기 위한 방법을 정의한다.** 네트워크상 **양쪽의 연결을 관리/지속**시키는 역할과 **세션을 만들거나 없애는** 역할을 담당하는 계층이다. 통신하는 **사용자들을 동기화하고 오류복구를 진행**한다. 통신연결은 포트를 기반으로 구성하여 연결되며, **OS가 세션계층에 속한**다.

---
## Frame, Packet, Segment, Datagram

- **Packet(패킷)**: 컴퓨터 간에 데이터를 주고받을 때, 네트워크를 통해 전송되는 **데이터 조각**을 패킷이라고 부른다. 송신 측(애플리케이션)은 많은 양의 데이터를 한번에 보내는 것이 아니라, **일정 단위로 잘라서 보낸다. 각 계층에서 필요한 정보는 캡슐화/역캡슐화되어 전달되고, 수신 측은 받은 패킷을 다시 조립해서 사용한다.**
- **Segment**: Transport 계층(L4)에서 신뢰할 수 있는 통신을 구현하기 위한 헤더를 데이터(L5 계층 데이터)에 붙이는데, 이렇게 만들어진 패킷을 세그먼트라고 부른다.
- **Datagram**: Network 계층(L3)에서 다른 네트워크와 통신하기 위한 헤더를 세그먼트(L4 계층 데이터)에 붙인것을 데이터그램, 데이터 세그먼트라고 부른다.
- **Frame**: 데이터 링크 계층(L2)에서 물리적인 통신 채널을 열기 위해 패킷에 헤더와 트레일러를 붙인다. 트레일러는 데이터를 전달할 때 데이터 끝 부분에 붙이는 정보로, 주로 에러 검출에 사용된다.
![Pasted image 20250305134410.png](/img/user/images/Pasted%20image%2020250305134410.png)

- 패킷을 잘라서 보내는 이유: **많은 데이터를 한번에 보내게 되면, 데이터 손실의 가능성이 있**으며, **대역폭을 너무 많이 차지하게 되므로 패킷의 흐름을 원활히 조절하기 위함이다.**

- 소켓(Socket), 포트(Port), 패킷(Packet)
	- **Socket**: 프로세스로부터 네트워크로 데이터를 전달하는 출입구(인터페이스) 역할을 한다. 수신 측 호스트의 트랜스포트 계층은 **실제로 데이터(세그먼트)를 직접 프로세스로 전달하지 않고, 중간 매개자인 소켓에게 전달한다.** 호스트에서는 하나 이상의 소켓이 존재할 수 있으므로 **소켓은 고유의 식별자를 가지고** 있어야한다. 같은 프로세스가 **같은 포트를 가지고도 여러 개의 소켓을 열 수 있기 때문에**, 소켓과 포트는 다른 개념이다.
	
	- **Port**: 프로세스를 식별하기 위해, 호스트 내부적으로 프로세스가 할당받는 고유한 값이다. 같은 호스트 내에서 서로 다른 프로세스가 같은 포트 넘버를 가질 수 있다. 하지만 같은 소켓을 사용하지는 못한다. 포트는 논리적인 접속장소이다.
	
> [!요약]
>**소켓**은 프로세스가 네트워크를 통해서 데이터를 주고받으려면 반드시 열어야 하는 창구 같은 것이고, 
> **포트**는 프로세스 식별을 위해 하나의 호스트에서 프로세스에 할당하는 고유값이고, 
> **패킷**은 네트워크 상의 데이터 조각을 말하는 것이다.

- 캡슐화, 역캡슐화
	![Pasted image 20250305150729.png](/img/user/images/Pasted%20image%2020250305150729.png)
	- 캡슐화: (데이터 송신 시)하위 계층으로 패킷을 보낼때, **하위계층에서 필요로하는 추가정보**(메타데이터)**를 헤더/트레일러에 추가**하여 보내게된다.
	- 역캡슐화: 데이터 수신 시, 상위 계층으로 패킷을 전달하고, 전달된 **패킷의 헤더를 차례대로 제거**하면서 데이터를 얻게 된다.

---
## TCP와 UDP의 차이

- TCP와 UDP는 모두 트랜스포트 계층(4계층)의 프로토콜이다. TCP와 UDP가 **공통적**으로 가지고 있는 기능은 아래와 같다.
	1. **트랜스포트 다중화/역다중화 기능**(Transport Multiplexing/Demultiplexing): **호스트 대 호스트 전달**을 **프로세스 대 프로세스 전달**로 확장
	2. **무결성 검사(오류검출)**: 헤더에 오류 검출 필드를 포함

- **UDP**: 위의 가장 기본적인 두가지 기능만을 제공한다. **비신뢰적인 서비스**로서, **프로세스에 의해서 전송된 데이터가 손상되지 않은채로 목적지에 도착하는 것을 보장하지 않는다.** 또한 **비연결형 서비스**이며, 오류검출은 선택사항이다.
	- 장점
		연결설정이 불필요하고 연결상태가 없다. 따라서 연결을 설정하기위한 어떠한 지연이 없고, 유지해야하는 정보가 없기 때문에 더 많은 클라이언트를 수용할 수 있다.
		또한 UDP의 패킷 오버헤드(8 byte per segment)가 TCP(20 byte per segment)에 비해 더 작다.
	- 단점 
		혼잡제어를 사용하지 않아, 네트워크가 폭주상태에 빠지는 것을 막을 수 없다는 단점과 신뢰적이지 않으므로, 몇몇의 정보를 잃어버릴 수 있다

- **TCP**: 가장 기본적인 두가지 기능도 제공하면서, **신뢰적인 데이터 전달**(Reliable Data Transfer) 기능, **연결지향형 서비스, 혼잡제어(Congestion control) 등의 기능을 제공**한다.
	- **신뢰적 데이터 전달**: 흐름제어, 순서번호, 확인응답, 타이머 등의 기술을 사용하여 프로세스에게 데이터가 순서대로 정확히 전달되도록 하는 역할을 한다. 종단 시스템 간에 IP의 비신뢰적인 서비스를 프로세스 사이의 신뢰적인 데이터 전송 서비스로 만들수 있으며, TCP에서의 오류검출은 필수사항이다.
	
	- **혼잡 제어**: 보내는 쪽(송신측)의 트래픽을 조절하여 스위치/링크의 혼잡을 방지하는 역할을 한다.

> [!요약]
> 따라서, **UDP는 속도증가와 지연 감소를 위해서** 많이 사용되고, **TCP는 신뢰성이 중요한 경우**에 사용된다. 
> 예를들어, UDP는 동영상 전송과 같이, 몇 프레임 정도 손실되어도 괜찮은 데이터 전송에 사용되고, TCP는 몇몇의 정보도 손실되어서는 안되는 애플리케이션에 이용된다.


--- 
## TCP와 UDP의 헤더 비교

- **UDP 헤더**
	![Pasted image 20250305140058.png](/img/user/images/Pasted%20image%2020250305140058.png)
	구성 필드: 출발지 포트, 목적지 포트, 체크섬, 길이 (총 8바이트)

- **TCP 헤더**
	![Pasted image 20250305140109.png](/img/user/images/Pasted%20image%2020250305140109.png)
	구성 필드: 출발지/목적지 포트, Sequence Number, Ack Number, 옵션 등 (기본 20바이트, 최대 60바이트)

- **포트번호**는 IP 정보와 결합하여 출발지, 도착지를 구분하기 위해 사용된다.
- **Sequence Number**는 SYN 패킷을 보낼때, 동기화를 위해 사용되는 번호이다. 초기 Sequence Number를 **ISN**이라 부르며, 여기에는 **랜덤한 수**가 담긴다.
- **Ack Number**는 ACK 패킷을 보낼 때 동기화를 위해 사용되는 번호이다.

--- 
## TCP의 3-way-handshake와 4-way-handshake를 비교

- **핸드셰이크**: 호스트 간 데이터를 전송하기 전에 **먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정**을 의미한다.

• **3-way Handshake (연결 설정)**: 
	![Pasted image 20250305140219.png](/img/user/images/Pasted%20image%2020250305140219.png)
	**TCP의 연결을 초기화 할 때 사용한다.**
	양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.
	
	1. 클라이언트가 SYN 전송
	2. 서버가 SYN+ACK 전송
	3. 클라이언트가 ACK 전송하여 연결 성립
	
	-> 2-way로도 충분해보이는데 3-way를 사용하는 이유: 양방향성 연결이기 때문

• **4-way Handshake (연결 종료)**
	![Pasted image 20250305140528.png](/img/user/images/Pasted%20image%2020250305140528.png)
	**세션을 종료하기 위해 수행되는 절차이다.**
	
	1. FIN 전송 (한 쪽 종료 의사 표시)
	2. 상대방이 ACK 전송 후, 데이터 전송 마무리
	3. 상대방이 FIN 전송
	4. 처음 FIN 전송한 쪽이 ACK 전송 및 TIME_WAIT 상태로 잔여 패킷 대기

> **💡 `CLOSE_WAIT` 와 `TIME_WAIT` 상태란 무엇일까?**  
> `TIME_WAIT` 상태로 대기하는 이유는, 세션 종료후, 혹시나 네트워크에 아직 라이브 패킷이 존재할수도 있기때문이다.

> **💡 용어**
> 
> - **SYN**(Synchronization): **연결요청, 세션을 설정하는데 사용**되며 초기에 시퀀스 번호를 보낸다.
> - **ACK**(Acknowledgement): **그 데이터가 올바르게 도착했음을 알리기 위해 사용**되며 보낸 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송한다.
> - **FIN**(Finish) : **세션을 종료시키는데 사용**되며 더 이상 보낸 데이터가 없음을 표시한다.

---
## TCP의 연결 설정 과정(3단계)와 연결 종료(4단계)에서 단계 차이가 나는 이유

- 연결 설정과 다르게, 연결 종료 과정에서 고려해야하는 경우가 존재한다. &rarr; **전송중인 데이터에 대한 경우**, 클라이언트가 아직 서버로부터 못 받은 데이터가 있을 것을 대비하여 일정시간 동안 세션을 남기고 **모든 데이터를 보냈다는 것을 의미하는 `FIN`을 받은 후에야 연결을 종료하기 때문이다.**

---
## FIN 패킷보다 늦게 도착하는 상황이 발생한다면?

- 패킷은 Drop되고 **데이터는 유실**될 것이다.
- 이러한 현상에 대비하여 Client는 Server로부터 `FIN`을 수신하더라도 일정시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 `TIME_WAIT` 라고 한다. 일정시간이 지나면, 세션을 만료하고 연결을 종료시키며, `CLOSE` 상태로 변화한다.

---
## 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유

- Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 **사용된 포트 번호 쌍을 사용하는 가능성이 존재한다.**

- **서버 측에서는 패킷의 SYN을 보고 패킷을 구분**하게 되는데 난수가 아닌 순차적인 number가 전송된다면 **이전의 connection으로부터 오는 패킷으로 인식할 수 있다.**

- 이러한 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정하는 것이다.

---
## HTTP와 HTTPS의 차이

- **HTTP**
	- **서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜**이다.
	- 비암호화 프로토콜, 기본 포트 80 사용, 속도가 빠르지만 보안 취약
	
- **HTTPS**
	- **HTTP에 데이터 암호화가 추가된 프로토콜**이다.
	- SSL/TLS를 통한 암호화, 기본 포트 443 사용, 보안성이 높으나 암호화 과정으로 인해 속도 약간 감소

- **개인 정보와 같은 민감한 데이터를 주고받아야 한다면 HTTPS**를 이용해야 하지만, **단순한 정보 조회 등 만을 처리하고 있다면 HTTP**를 이용하면 된다.

---
## HTTP 요청/응답 헤더의 구조

- 요청/응답 헤더: 요청 메타데이터(메서드, URL, 프로토콜 버전, 상태 코드 등)와 다양한 필드(Host, User-Agent, Cookie, Content-Type 등)를 포함하여 클라이언트와 서버 간 정보 교환을 지원

---
## HTTP와 HTTPS 동작 과정 비교

- **HTTP**: 단순 요청-응답 방식으로 동작
- **HTTPS**: 클라이언트와 서버 간 TLS 핸드셰이크를 통해 보안 채널 설정 후, 암호화된 요청-응답 방식으로 데이터 교환

---
## CORS

![Pasted image 20250305142405.png](/img/user/images/Pasted%20image%2020250305142405.png)
- **CORS**: 웹 브라우저가 다른 출처의 리소스에 접근할 수 있도록 추가 HTTP 헤더(Origin, Access-Control-Allow-Origin 등)를 사용해 권한 부여

- **동작 원리**:
	1. 클라이언트 요청 시 Origin 헤더 포함 
	2. 서버가 허용 출처를 응답 헤더로 명시
	3. 브라우저가 비교 후 요청 허용 여부 결정

---
## HTTP GET과 POST 메서드를 비교/설명

- **GET**: URL의 쿼리 스트링으로 데이터 전송, 멱등적(여러 번 요청해도 결과 동일), 주로 **조회용**

- **POST**: HTTP 메시지 body에 데이터 전송, 멱등하지 않음, **데이터 생성** 용도

- 차이점: **GET**은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 **HTTP 메시지에 body가 없다.** **POST**는 body에 데이터를 담아 보내기 때문에 당연히 **HTTP 메시지에 body가 존재한다.**

---
## 쿠키와 세션

- **쿠키**: 클라이언트(브라우저)에 저장되는 작은 데이터 파일, 서버와의 요청 시 자동 전송, 보안 취약성 존재
	- 동작 방식
		1. 클라이언트가 페이지를 요청
		2. 서버에서 쿠키를 생성
		3. HTTP 헤더에 쿠키를 포함 시켜 응답
		4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관
		5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
		6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때 쿠키를 업데이트하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

- **세션**: 서버 측에서 관리되는 사용자 상태 정보, 세션 ID를 통해 식별, 보안성은 높지만 서버 자원 소모가 큼
	- 동작 방식
		1. 클라이언트가 서버에 접속 시 세션 ID를 발급
		2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
		3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용
		4. 서버는 세션 ID를 전달받아서 별다른 작업 없이 세션 ID로 세션에 있는 클라언트 정보를 가져옴
		5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

- **차이점**
	- **사용자의 정보가 저장되는 위치**: 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용한다.
	- **보안**: 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하다. 반면 세션은 쿠키를 이용해서 세션 ID만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋다.
	- **라이프 사이클**: 쿠키는 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료 기간을 넉넉하게 잡아두면 쿠키 삭제를 할 때까지 유지될 수도 있다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
	- **속도**: 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르다. 반면 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

---
## DNS
- 도메인 이름(예: www.google.com)을 IP 주소로 매핑하는 역할을 한다.

- 브라우저가 도메인에 해당하는 IP를 찾는 순서
	1. **local cache** 안에 검색한 해당 도메인의 IP가 있는지 확인한다. 이미 해당 도메인을 방문한 적이 있다면 컴퓨터가 해당 도메인의 IP를 기억하고 있으므로 그것을 사용한다.
	2. 만약 캐시에 없다면 컴퓨터 내부에 **파일 형태로 존재하는 hosts 파일을 검색**해서 찾는다. 해당 hosts 파일에 특정 도메인과 IP를 매핑 시켜놓으면 해당 도메인은 지정한 IP로 이동한다.
	3. 만약 위의 경우에서 도메인에 대한 IP를 찾지 못하면 **최종적으로 DNS를 검색한다**.

![Pasted image 20250305143242.png](/img/user/images/Pasted%20image%2020250305143242.png)

---
## REST와 RESTful

- **REST (Representational State Transfer)**
	- URI를 통해 자원(DB)을 식별하고, HTTP 메서드로 CRUD 연산을 수행하는 아키텍처 스타일
		- Create
		- Read
		- Update
		- Delete
- **RESTful**
	- REST 원칙에 따라 구현된 웹 서비스를 지칭, "REST API를 제공하는 웹 서비스는 RESTful하다"처럼 사용된다.

- HTTP 메서드    
	GET: 데이터 조회
	POST: 데이터 등록, 인증 작업을 거칠 때 사용하기도 함
	DELETE: 데이터 삭제
	PUT: 데이터를 전체적으로 업데이트할 때 사용
	PATCH: 데이터를 일부만 수정할 때 사용

- URL: 자원을 식별자로 취급하여 나타내는 주소를 말한다. URI의 종류로 URL과 URN이 있다. URI는 일반적으로 다음과 같은 형식을 갖고 있다.
	![Pasted image 20250305144226.png](/img/user/images/Pasted%20image%2020250305144226.png)

--- 
## Socket이란?

- **소켓**: Application 프로세스와 end-to-end 통신을 제공하는 Transport 프로토콜 사이의 인터페이스을 말한다. 즉, **Application에서 Transport 프로토콜을 쓰기 위한 API를 말한다.**

- 크게 UDP와 TCP의 두 종류로 분류할 수 있다. 아래는 파이썬 코드로 표현한 것이다.

> **TCP**

- TCP Client
```python
from socket import *

server_name = "example.com"
server_port = 1234

client_socket = socket(AF_INET, SOCKET_STREAM)  # 소켓 생성
client_socket.connect((server_name, server_port)) # 서버에 연결 요청
```

- TCP Server
```python
from socket import *

server_port = 1234

server_socket = socket(AF_INET, SOCKET_STREAM)  # 소켓 생성
server_socket.bind(('', server_port)) # 소켓에 주소 바인딩
server_socket.listen(1) # 클라이언트 연결 대기

(client_socket, client_address) = server_socket.accept()  # 클라이언트 연결 수락
```

> **UDP**

- UDP Client
```python
from socket import *

server_name = "example.com"
server_port = 1234

client_socket = socket(AF_INET, SOCK_DGRAM) # 소켓 생성
```

- UDP Server
```python
from socket import *

server_port = 1234
server_socket = socket(AF_NET, SOCK_DGRAM)  # 소켓 생성
server_socket.bind(('', server_port)) # 소켓에 주소 바인딩
```

---
## Socket.io와 WebSocket의 차이

- **WebSocket**: **브라우저와 서버 간** 지속적이고 **양방향** 통신을 위한 프로토콜
	![Pasted image 20250305144527.png](/img/user/images/Pasted%20image%2020250305144527.png)
	
- **Socket.io**: WebSocket을 포함하여 다양한 브라우저 환경에 맞춰 자동으로 최적의 통신 기술 선택해 양방향 통신을 구현하는 라이브러리

---
## IPv4와 IPv6 차이

- **인터넷 프로토콜(IP)의 버전을 의미**한다. 주로 호스트 간 패킷 혹은 데이터그램을 불리는 정보를 주고 받을 때 사용한다.
![Pasted image 20250305144734.png](/img/user/images/Pasted%20image%2020250305144734.png)
- **IPv4**: **32비트 주소**, 헤더 옵션과 fragmentation 지원, 각 라우터마다 checksum 갱신
	- fragmentation: MTU(Maximum Transport Unit)을 넘는 큰 데이터그램을 쪼개 전송을 하고 도착지에서 재조합을 한다.
- **IPv6**: **128비트 주소**, fragmentation 기능 없음(빠른 속도를 위해), 우선순위 지정(**priority 비트**) 등의 개선 사항 포함

---
## MAC Address란

- MAC 주소: Data Link Layer에서 통신을 위해 **네트워크 인터페이스에 할당한 식별자**를 말한다. 즉, **모든 네트워크 장비는 자신의 MAC 주소가 있으며** 주소는 장비 제조업체가 할당한다. MAC 주소는 물리적 주소(Physical Address)라고 불리기도 한다.

**💡 MAC 주소와 IP 주소의 차이**  
**MAC 주소와 IP 주소 모두 통신기기의 식별자라는 것은 동일하다.** 다만 MAC 주소는 제조업체가 통신기기에 부여하는 식별자이며 **같은 식별자를 같는 통신기기는 없다**. IP 주소는 **Network Layer에서 통신을 하기 위한 주소로 보통 통신사에서 부여하며 바뀔 수 있다.**

---
## 라우터, 스위치, 허브 차이

![Pasted image 20250305145325.png](/img/user/images/Pasted%20image%2020250305145325.png)

- **라우터(Router)**: **Network Layer 3계층 장비**로 **네트워크 사이를 연결하는 장치**이다. 최종 도착지의 네트워크에 도착할 수 있도록 적절한 경로를 설정하여 패킷을 전송한다.

- **스위치(Switch)**: **Data Link Layer 2계층 장비**로 **네트워크 내에서 패킷을 전송하는 장치**를 말한다. 스위치로 요청이 들어오면 IP 주소에 대응되는 MAC 주소를 찾아 해당 MAC 주소로 패킷을 전송한다. 만약 IP 주소에 대응되는 MAC 주소가 없다면 허브처럼 **브로드캐스트** 방식으로 패킷을 전송하고 IP 주소와 MAC 주소를 대응시킨 테이블을 갱신시킨다.
	- 브로드캐스트: LAN에 있는 모든 네트워크 장비들에게 보내는 통신이다.
- **허브(Hub)**: **Physical Layer 1계층 장비**로 **여러 기기를 연결하여 네트워크를 만들어주는 장치**이다. 패킷을 받으면 연결된 모든 기기에 패킷을 전송한다.

---
## SMTP

- `SMTP(Simple Mail Transfer Protocol)`은 **인터넷에서 이메일을 보내기 위해 사용하는 TCP/IP 프로토콜**을 말한다. 사용하는 TCP Port 번호는 25번이다.
	- MAIL 명령: 주소 반환 확립
	- RCPT 명령: 메시지 수신자 확립
	- DATA 명령: 메시지 텍스트의 첫 신호를 제공

---
## 네트워크 topology
![Pasted image 20250305145546.png](/img/user/images/Pasted%20image%2020250305145546.png)

- **Star(성형)**: 중앙 노드를 통해 연결, 장애 발견 및 관리 용이하지만 중앙 장애 시 전체 영향

- **Bus(선형)**: 공통 버스(배선)를 사용하여 연결, 노드 설치와 확장이 용이하고 장애가 다른 노드에 영향을 주지 않음,  대역폭 제한 존재해 과부화로 인한 네트워크 성능 저하 발생 가능

- **Ring(링형)**: 원형 연결, 단방향 통신, 노드 추가/삭제가 어려움

- **Mesh(망형)**: 각 노드가 다수 연결되어 안정적이나 구축 비용과 복잡성 증가

- **Tree(트리형)**: 네트워크의 확장에 용이, 장애가 전체 네트워크에 미치는 영향을 줄임. 
	단, 최상위 루트 노드나 백본에 문제가 발생하면, 그 하위에 있는 모든 네트워크 구역이 영향을 받음

---
## subnet mask &rarr; 이건 좀 이해가 안가는디..

> **IP 주소와 서브네팅 (subnetting)**

IPv4 의 경우 $2^{32}$의 숫자로 주소를 표현하고, 이를 국가, 회사 등 잘게 나눠 어느 영역을 쓰게할 것인지 결정한다.

한정된 자원이기 때문에 효율적으로 노드에 주소를 할당하는게 중요하다. **이를 위해 IP 를 쪼개는, 네트워크 파트 + 호스트 파트로 구성하는 서브네팅을 활용한다.**

기본적으로 IP 주소에 따라 5개의 클래스로 구분된다. 각 클래스에 따라 네트워크 파트와 호스트 파트가 정해진다.
![Pasted image 20250305150409.png](/img/user/images/Pasted%20image%2020250305150409.png)
위와 같은 클래스 구조와 더불어 더욱 효율적인 서브네팅을 위해서 사용하는 방법이 서브넷 마스크이다.

> **서브넷 마스크 (subnet mask)**

할당된 IP 주소는 **기본적으로 네트워크 파트와 호스트 파트가 정해져있다.**

**효율적인 주소 관리를 위해 내부적으로 호스트 파트를 새로운 네트워크 파트와 호스트 파트로 나눌 수 있다.** 이 때 **서브넷 마스크를 활용할 수 있다.**

만약 C 클래스인 192.12.16.1 IP, 255.255.255.0 서브넷 마스크(호스트 파트)가 할당되었을 때 기존의 서브넷 마스크인 마지막 8 비트를 1111 0000 으로 바꾼다면, 4 비트만큼의 네트워크 파트 (그룹), 4 비트만큼의 호스트 (멤버) 를 할당할 수 있다. 이렇게 된다면 동일 네트워크 간에는 커뮤니케이션이 자유롭지만, 다른 네트워크 간에는 라우터를 거쳐야 커뮤니케이션을 할 수 있다.

어떤 기업을 생각해보자. 서브넷 마스크로 추가적인 서브네팅을 안한다면 인사팀, 재무팀 등등 여러 팀들이 모두 같은 네트워크 파트를 지니므로 서로에게 접근할 수 있다. 이럴 때 서브넷 마스크를 활용한 서브네팅으로 효율적으로 IP 를 관리할 수 있다.

---
## DHCP

- DHCP: **동적으로 IP 주소나 기타 정보들을 관리해주는 프로토콜**을 말한다. 관리해야하는 컴퓨터가 많고 이들의 IP 를 모두 직접 할당하고 관리하려면 상당히 복잡하고 시간이 많이들지만, DHCP 를 사용하면 이러한 문제점을 해결할 수 있다.
	- 과정
		1. `DHCP discover`: 컴퓨터가 동일 서브넷으로 브로드캐스팅(255.255.255.255)으로 DHCP 서버를 찾는다.
		2. `DHCP offer`: DHCP 가 사용가능한 IP 주소의 리스트를 컴퓨터에게 전달한다.
		3. `DHCP request`: 컴퓨터가 리스트 중 하나의 IP 주소를 선택하여 서버에 전달한다.
		4. `DHCP ack`: DHCP 가 컴퓨터에게 해당 IP 주소를 허락/거절하는 메세지를 전달한다.

- 장점
	- DHCP 서버에서 자동으로 IP 를 관리해주므로 편리하다. IP 에 변동이 있을 때, DHCP 에만 정보를 입력하면 된다.
	- 사용중인 컴퓨터에 대해서만 할당하므로 효율적이다.

- 단점
	- DHCP 서버에 의존하기 때문에 서버가 다운되는 경우 모든 컴퓨터에서 인터넷을 할 수 없다.
	- 초기 DHCP 세팅 시간 및 트래픽이 크다.
	- 단말 컴퓨터를 끌 경우, 완전히 주소가 release 될 때 까지 해당 IP 를 사용할 수 없다.

---
## 라우팅 프로토콜 (Link State vs. Distance Vector)

- 라우팅: 패킷을 전달할 때 어느 경로로 갈지 정하는 것을 의미한다.

![Pasted image 20250305151045.png](/img/user/images/Pasted%20image%2020250305151045.png)
- **정적 라우팅**: 네트워크 라우터의 경로를 네트워크 관리자가 수동으로 설정하는 방식
- **동적 라우팅**: 정적 라우팅과 달리 네트워크 상황에 따라 경로를 동적으로 갱신
	![Pasted image 20250313164043.png](/img/user/Pasted%20image%2020250313164043.png)
	- **IGP**: 하나의 네트워크 관리자에 의해 관리되는 네트워크 집단(AS)을 기준으로 내부 라우팅
		- **Distance Vector**: 각 노드가 인접 노드로부터 거리와 방향 정보를 받아 라우팅 테이블 갱신 (예: RIP, IGRP, BGP)
			간단하지만 루핑 문제가 발생할 수 있음 (벨만–포드 알고리즘 기반)
		- **Link State**: 네트워크 내 모든 노드가 전체 토폴로지를 파악하여 경로 계산 (예: OSPF, IS-IS)
			정확하나 CPU, 메모리 자원 소모가 큼 (다익스트라 알고리즘 기반)
	- **EGP**: AS기준 외부 라우팅

--- 
## 이더넷이란?

- 이더넷: 근거리 유선 통신을 위해 사용되는 네트워킹 방법으로 **CSMA/CD**프로토콜을 사용한다. IEEE 802.3 에 표준으로 정의되었다.

- 장점
	- 적은 용량의 데이터를 보낼 때 성능이 좋다.
	- 비용이 적고 관리가 쉽다.
	- 구조가 단순하다.
- 단점
	- 캐리어 충돌이 발생할 수 있다.
	- 충돌이 발생하면 지연이 생긴다.
> [!용어]
> **CSMA/CD vs CSMA/CA**
> - CSMA/CD (Collision Detection)
> 	- 주로 유선 네트워크(Ethernet)에서 사용
> 	- 채널을 감시할 수 있기 때문에 충돌이 발생하면 즉시 중단하고 대응 가능
> 	- 충돌이 발생하면 네트워크 자원을 낭비하게 되지만, 유선 환경에서는 신호 감지가 비교적 정확하여 효율적으로 동작
> - CSMA/CA (Collision Avoidance)
> 	- 무선 네트워크(Wi-Fi)에서 사용
> 	- 무선 환경에서는 충돌 감지가 어려움
> 	- RTS/CTS(Request to Send / Clear to Send) 핸드셰이크 등의 절차를 사용하여 실제 전송 전에 충돌 가능성을 최소화
> 	- 오버헤드가 증가하지만, 무선 특성에 맞게 설계

---
## Client와 Server 차이

- 네트워크 상에서 **요청을 보내는 대상을 `client`**, **요청에 응답하는 대상을 `server`** 라고 한다. client 와 server 는 고정되지 않고 요청에 따라 바뀐다.

---
## Delay, Timing(jitter), Throughput의 차이

- 위 3가지 용어 모두 네트워크 성능을 나타낸다.

- **Delay (지연)**:
	- 패킷이 **출발지에서 도착지까지 전달되는 전체 시간**
	- 구성
		- `Processing Delay (처리 지연)`: 라우터가 들어온 패킷의 헤더를 확인하고 처리하는데 걸리는 시간
		- `Queueing Delay (큐 지연)`: 라우터가 다른 패킷을 처리하느라 패킷이 라우터의 큐에서 대기하는 시간
		- `Transmission Delay (전송 지연)`: 라우터의 성능 (전송 속도) 에 따라 패킷이 논리회로를 통과할 때까지 걸리는 시간
		- `Propagation Delay (전파 지연)`: 라우터간 거리에 의해 발생하는 지연 시간
	![Pasted image 20250305152301.png](/img/user/images/Pasted%20image%2020250305152301.png)

- **Jitter (지터)**:
	- 패킷 지연 시간의 변동 폭, **일정하지 않은 전송 지연**을 의미

- **Throughput (처리량)**:
	- **단위 시간당 실제 전송되는 데이터 양**, 네트워크의 효율성을 나타냄